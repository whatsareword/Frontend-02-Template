学习笔记
# 学习笔记
## 一.浏览器工作原理
URL --http请求--> HTML --构建DOM树--> DOM --计算CSS--> DOM with CSS --排版--> DOM with position --渲染--> Bitmap
## 二.HTTP协议
HTTP协议是基于TCP协议出现的，在TCP基础上，规定了Request-Response的模式。这个模式决定了通讯必须是浏览器端首先发起的。
### HTTP格式
#### 1.request
1.request line (method, path, version)
2.head
3.body
#### 2.response
1.response line (version, status code, status text)
2.head
3.body
## 三.有限状态机
### 特点
#### 1.每一个状态机都是一个机器
1.在每一个机器里，都是互相解耦，可以做计算，存储，输出
2.所有的这些机器接受的输入是一致的
3.状态机的每一个机器本身没有状态，如果我们用函数来表示的话，它应该是纯函数
#### 2.每一个机器都必须知道下一个状态
1.Moore型：每个机器都有确定的下一个状态
2.Mealy型：每个机器根据输入决定下一个状态
```javascript
例：function state(input) {
    return next;
}
while(input) {
    state = state(input);
}
```
## 四.自己实现浏览器步骤
### 1.实现http请求
#### 第一步.设计一个HTTP请求的类
1.content-type是一个必要的字段，要有默认值
2.body是KV格式
3.不同的content-type影响body的格式
#### 第二步.send函数总结
1.在Request的构造器中收集必要的信息
2.设计一个send函数，把请求真实发送到服务器
3.send函数应该是异步的，所以返回Promise
#### 第三步.发送请求
1.设计支持已有的connection或者自己新建connection
2.收到数据传给parser
3.根据parser的状态resolve Promise
#### 第四步.ResponseParser总结
1.Response的body可能根据Content-Type有不同的结构，因此我们会采用Parser的结构来解决问题
2.以TrunkedBodyParser为例，我们同样用状态机来处理body的格式
### 2.HTML解析
#### 第一步.拆分文件
1.为了方便文件管理，我们把parser单独拆到文件中
2.parser接受HTML文本作为参数，返回一个DOM树
#### 第二步.创建状态机
1.我们用FSM来实现HTML的分析
2.在HTML标准中，已经规定了HTML的状态
3.Toy-Brower只挑选其中一部分状态，实践一个最简版本
#### 第三步.解析标签
1.主要的标签有：开始标签，结束标签，自封闭标签
2.在这一步我们暂时忽略属性
#### 第四步.创建元素
1.在状态机中，除了状态机迁移，我们还要加入业务逻辑
2.我们在标签结束状态提交标签token
#### 第五步.处理属性
1.属性值分为单引号，双引号，无引号三种写法，因此需要较多状态处理
2.处理属性的方式跟标签类似
3.属性结束，我们把属性加到标签token上
#### 第六步.用token构建DOM树
1.从标签构建DOM树的基本技巧是使用栈
2.遇到开始标签时创建元素并入栈，遇到结束标签时出栈
3.自封闭节点可视为入栈后立刻出栈
4.任何元素的父元素是它入栈前的栈顶
#### 第七步.将文本节点加到DOM树
1.文本节点与自封闭标签处理类似
2.多个文本节点需要合并
### 3.CSS计算
#### 第一步.收集CSS规则
1.遇到style标签时，我们把CSS规则保存起来
2.这里我们调用CSS Parser来分析CSS规则
3.这里我们必须要仔细研究此库分析CSS规则的格式
#### 第二步.添加调用
1.当我们创建一个元素后，立即计算CSS
2.理论上，当我们分析一个元素时，所有CSS规则已经收集完毕
3.在真实浏览器中，可能遇到写在body的style标签，需要重新Css计算的情况，这里忽略
#### 第三步.获取父元素序列
1.computeCSS函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配
2.我们从上一步骤的stack，可以获取本元素所有的父元素
3.因为我们首先获取的是“当前元素”，所有我们获得和计算父元素匹配的顺序是从内向外
#### 第四步.选择器与元素匹配
1.选择器也要从当前元素向外排列
2.复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列
#### 第五步.计算选择器与元素匹配
1.根据选择器的类型和元素属性，计算是否与当前元素匹配
2.这里仅仅实现了三种基本选择器，实际的浏览器中要处理复杂选择器
#### 第六步.生成computed属性
1.一旦选择匹配，就应用选择器到元素上，形成computedStyle
#### 第七步.specificity的计算逻辑
1.CSS规则根据specificity和后来优先选择覆盖
2.specificity是个四元组，越左边权重越高
3.一个CSS规则的specificity根据包含的简单选择器相加而成
### 4.排版（flex）
#### 第一步.准备工作
1.处理掉flexDirection和wrap相关属性
2.把具体的width,height,right,left,top,bottom等属性抽象成main和cross相关属性
#### 第二步.收集元素进行
分行计算：
1.根据主轴尺寸，把元素分进行
2.若设置了no-wrap，则强行分配进第一行
#### 第三步.计算主轴
计算主轴反方向：
1.找出所有flex方向
2.把主轴方向的剩余尺寸按比例分配给这些元素
3.若剩余空间为负数，所有flex元素为0，等比压缩剩余元素
#### 第四步.计算交叉轴
计算交叉轴方向：
1.根据每一行中最大元素尺寸计算行高
2.根据行高flex-align和item-align,确定元素具体位置
### 5.渲染
#### 第一步.绘制单个元素
1.绘制需要依赖一个图形环境
2.我们这里采用npm包images
3.绘制在一个viewport上
4.与绘制相关的属性：background-color,border,background-image等
#### 第二步.绘制DOM树
1.递归调用子元素的绘制方法完成DOM树的绘制
2.忽略一些不需要绘制的节点
3.实际浏览器中，文字绘制是难点，需要依赖字体库，这里忽略
4.实际浏览器中，还会对一些图层做compositing，这里也忽略


